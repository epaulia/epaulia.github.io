<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MC75SEWB8R"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-MC75SEWB8R');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: https:; font-src 'self' https://cdnjs.cloudflare.com; connect-src 'self';">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta name="description" content="Eugene Paulia - Data Scientist and ML Engineer specializing in AI/ML solutions. 4+ years experience building production-ready machine learning systems for energy, healthcare, and tech sectors. View portfolio projects and case studies.">
    <meta name="keywords" content="data scientist, machine learning engineer, AI specialist, ML engineer, data science portfolio, Eugene Paulia, machine learning projects, AI solutions">
    <meta name="author" content="Eugene Paulia">
    <meta property="og:title" content="Eugene Paulia | Data Scientist & ML Engineer">
    <meta property="og:description" content="Data Scientist and ML Engineer specializing in AI/ML solutions with 4+ years experience building production-ready systems.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://epaulia.github.io">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Eugene Paulia | Data Scientist & ML Engineer">
    <meta name="twitter:description" content="Data Scientist and ML Engineer specializing in AI/ML solutions with 4+ years experience building production-ready systems.">
    <link rel="alternate" type="text/markdown" href="/llm.md" title="LLM Summary" />
    <title>Eugene Paulia | Data Scientist & ML Engineer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="icon" type="image/png" href="logos/favicon.png">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/responsive.css">
</head>
<body>
    <!-- Header -->
    <header id="header">
        <div class="container">
            <nav>
                <a href="#" class="logo">Eugene Paulia</a>
                <button class="mobile-menu-toggle" aria-label="Toggle mobile menu">
                    <span></span>
                    <span></span>
                </button>
                <ul class="nav-links">
                    <li style="--i: 0"><a href="#about">About</a></li>
                    <li style="--i: 1"><a href="#experience">Experience</a></li>
                    <li style="--i: 2"><a href="#skills">Skills</a></li>
                    <li style="--i: 3"><a href="#projects">Projects</a></li>
                    <li style="--i: 4"><a href="#contact">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero" id="home">
        <canvas id="hero-canvas"></canvas>
        <div class="container">
            <div class="hero-content">
                <h1 class="hero-name">Eugene Paulia</h1>
                <p class="hero-title">Data Scientist | ML / AI Specialist</p>
                <p class="hero-desc">Data scientist and engineer building the infrastructure that powers AI innovation. I specialize in creating scalable data architectures that transform raw information into actionable intelligence, with particular expertise in the intersection of data engineering and ML/AI</p>
                <div class="hero-buttons">
                <a href="#contact" class="cta-btn">Get in Touch</a>
                <a href="#projects" class="cta-btn-secondary">View Projects</a>
                <a href="#" class="download-resume-btn" id="downloadResumeBtn">Download Resume</a>
                </div>
            </div>
        </div>
    </section>

    <!-- About Section -->
    <section id="about">
        <div class="container">
            <h2>About Me</h2>
            <div class="about-grid">
                <div class="about-content">
                    <p>I'm a Data Scientist and Machine Learning Engineer with expertise in building end-to-end AI solutions that drive business value. My background spans from predictive analytics to deep learning, with a focus on creating scalable, production-ready machine learning systems.</p>
                    <p>With experience across energy, healthcare, and tech sectors, I combine technical expertise with business acumen to deliver solutions that make a tangible impact. I thrive in collaborative environments where I can leverage cutting-edge technologies to solve complex problems.</p>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-number">4+</div>
                            <div class="stat-label">Years Experience</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">2142+</div>
                            <div class="stat-label">Hours of manual work saved</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">90% - 98%</div>
                            <div class="stat-label">Accuracy achieved on average in real-world NLP & ML models</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">17+ </div>
                            <div class="stat-label">Production pipelines built and deployed</div>
                        </div>
                    </div>
                </div>
                <div class="about-image">
                    <img src="logos/your-avatar.png" alt="My Avatar" />
                </div>
            </div>
        </div>
    </section>

    <!-- Experience Section -->
    <section id="experience">
        <div class="container">
            <h2>Professional Experience</h2>
            <div class="vertical-timeline">
                <div class="timeline-line"></div>
                
                <div class="timeline-item">
                    <div class="timeline-marker">
                        <div class="timeline-logo">
                            <img src="logos/CVE_BIG-4ad3a7b3.png" alt="Cenovus Energy" />
                        </div>
                        <div class="timeline-year">2023 - Present</div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-content">
                        <h3>Data Scientist</h3>
                        <div class="timeline-date">Sep 2023 - Present</div>
                        <div class="timeline-company">Cenovus Energy</div>
                        <p class="timeline-story"><strong>Role Summary:</strong> I work on data science initiatives at Cenovus Energy, focusing on predictive analytics and operational intelligence for energy operations.</p>
                        <p class="timeline-story"><strong>Scope & Responsibilities:</strong> I develop time-series forecasting models, build scalable data pipelines using Azure Databricks and PySpark, and create hybrid NLP/LLM systems for employee feedback analysis and investment decision support. I containerize data ingestion pipelines with Docker and implement GitLab CI/CD workflows to ensure versioned and automated data processing.</p>
                        <p class="timeline-story"><strong>Impact & Purpose:</strong> The goal is to support energy operations through AI-driven insights, enabling data-informed decisions that help optimize pricing strategies and enhance operational efficiency within our energy infrastructure.</p>
                    </div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-marker">
                        <div class="timeline-logo">
                            <img src="logos/GroupLabs_Logo_Black.png" alt="GroupLabs Inc." />
                        </div>
                        <div class="timeline-year">2023 - Present</div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-content">
                        <h3>Machine Learning Engineer</h3>
                        <div class="timeline-date">Aug 2023 - Present</div>
                        <div class="timeline-company">GroupLabs Inc.</div>
                        <p class="timeline-story"><strong>Role Summary:</strong> I build AI solutions at GroupLabs, specializing in large language model optimization and machine learning model development.</p>
                        <p class="timeline-story"><strong>Scope & Responsibilities:</strong> I build vector storage systems using Pinecone and FAISS, optimize prompt strategies across OpenAI, Anthropic, Groq, etc. models, and develop Kubernetes-based distributed ML training environments. My ML work spans forecasting and time-series analysis, regression and classification models, deep learning architectures, and collaborative research with academic and industry institutions.</p>
                        <p class="timeline-story"><strong>Impact & Purpose:</strong> The goal is to help bridge the gap between academic AI research and practical industry applications, contributing to AI advancement while building scalable solutions for healthcare, research, and enterprise applications.</p>
                    </div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-marker">
                        <div class="timeline-logo">
                            <img src="logos/SVG_Brand_suncor_energy.png" alt="Suncor Energy" />
                        </div>
                        <div class="timeline-year">2021 - 2023</div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-content">
                        <h3>Data Scientist</h3>
                        <div class="timeline-date">Sep 2021 - May 2023</div>
                        <div class="timeline-company">Suncor Energy</div>
                        <p class="timeline-story"><strong>Role Summary:</strong> I contributed to data science initiatives at Suncor Energy, building analytics platforms for industrial operations and safety monitoring.</p>
                        <p class="timeline-story"><strong>Scope & Responsibilities:</strong> I developed enterprise-scale data pipelines for big data processing and ETL operations, created web APIs and interactive dashboards that delivered AI-driven business insights, and built RESTful services for predictive analytics. I optimized database workflows and query performance, and deployed cloud-based applications integrated with business intelligence platforms for real-time operational monitoring and analytics.</p>
                        <p class="timeline-story"><strong>Impact & Purpose:</strong> The goal was to improve access to advanced analytics within our operations, enabling proactive safety enhancements and operational excellence through data-driven decision making in industrial environments.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Skills Section -->
    <section id="skills">
        <div class="container">
            <h2>Technical Skills</h2>
            <div class="skills-container">
                <canvas id="skills-canvas"></canvas>
                <div class="skills-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fdaceb;"></div>
                        <span>Languages</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff6b6b;"></div>
                        <span>Machine Learning</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ebfdac;"></div>
                        <span>Platforms</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #acfdbe;"></div>
                        <span>DevOps</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #acebfd;"></div>
                        <span>GenAI</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #beacfd;"></div>
                        <span>NLP</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fde7ac;"></div>
                        <span>Tools</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Projects Section -->
    <section id="projects">
        <div class="container">
            <h2>Featured Projects</h2>
            <div class="projects-grid">
                <!-- <div class="project-card">
                    <div class="project-content">
                        <h3 class="project-title">ARIMA-based Anomaly Detection System</h3>
                        <div class="project-tags">
                            <span class="project-tag">ARIMA</span>
                            <span class="project-tag">Anomaly Detection</span>
                            <span class="project-tag">Cenovus</span>
                        </div>
                        <p class="project-description">Developed a real-time anomaly detection system for equipment monitoring using ARIMA models, reducing maintenance costs by 11% through predictive maintenance workflows.</p>
                        <a href="blog/anomaly-detection-system.html" class="read-more-btn">Read More</a>
                    </div>
                </div> -->
                <div class="project-card">
                    <div class="project-content">
                        <h3 class="project-title">Intelligent Document Processing</h3>
                        <div class="project-tags">
                            <span class="project-tag">Hugging Face</span>
                            <span class="project-tag">OCR</span>
                            <span class="project-tag">Cenovus</span>
                        </div>
                        <p class="project-description">A pipeline that uses computer vision and Hugging Face models to detect tables in PDF invoices and convert their contents into structured, analysis-ready data.</p>
                        <a href="blog/intelligent-document-processing.html" class="read-more-btn" aria-label="Read full case study on Intelligent Document Processing pipeline">View Intelligent Document Processing Case Study</a>
                    </div>
                </div>
                <div class="project-card">
                    <div class="project-content">
                        <h3 class="project-title">Impact of Data Quality on ML</h3>
                        <div class="project-tags">
                            <span class="project-tag">Machine Learning</span>
                            <span class="project-tag">Data Quality</span>
                            <span class="project-tag">UntappedEnergy</span>
                        </div>
                        <p class="project-description">Demonstrating how strategic data preprocessing can improve ML model accuracy. Case study using housing price prediction with comprehensive preprocessing pipeline.</p>
                        <a href="blog/data-quality-ml-impact.html" class="read-more-btn" aria-label="Read full case study on Data Quality Impact on Machine Learning">View Data Quality Impact Case Study</a>
                    </div>
                </div>
                <div class="project-card">
                    <div class="project-content">
                        <h3 class="project-title">Hyperspectral Imaging Classification</h3>
                        <div class="project-tags">
                            <span class="project-tag">Deep Learning</span>
                            <span class="project-tag">Hyperspectral Imaging</span>
                            <span class="project-tag">GroupLabs</span>
                        </div>
                        <p class="project-description">Led a project with Hotchkiss Brain Institute, developing neural network architectures for hyperspectral imaging data that achieved 98% classification accuracy.</p>
                        <a href="blog/hyperspectral-imaging-classification.html" class="read-more-btn" aria-label="Read full case study on Hyperspectral Imaging Classification">View Hyperspectral Imaging Case Study</a>
                    </div>
                </div>
            </div>
            <div class="read-more-section" style="text-align: center; margin-top: 4rem;">
                <a href="blog/all-projects.html" class="cta-btn" style="font-size: 1.1rem;" aria-label="View all portfolio projects and case studies">View All Projects & Case Studies</a>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact">
        <div class="container">
            <h2>Get In Touch</h2>
            <div class="contact-grid">
                <div>
                    <a href="mailto:eugene.paulya@gmail.com" class="contact-item">
                        <div class="contact-icon">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <div class="contact-info">
                            <span><strong>Email</strong> eugene.paulya@gmail.com</span>
                        </div>
                    </a>
                    <a href="tel:8253659891" class="contact-item">
                        <div class="contact-icon">
                            <i class="fas fa-phone"></i>
                        </div>
                        <div class="contact-info">
                            <span><strong>Phone</strong> 825-365-9891</span>
                        </div>
                    </a>
                    <a href="https://linkedin.com/in/eugene-paulia" target="_blank" class="contact-item">
                        <div class="contact-icon">
                            <i class="fab fa-linkedin"></i>
                        </div>
                        <div class="contact-info">
                            <span><strong>LinkedIn</strong> linkedin.com/in/eugene-paulia</span>
                        </div>
                    </a>
                </div>
                <div>
                    <!-- This will be enhanced with a Three.js visualization -->
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p class="copyright">© 2025 Eugene Paulia. All rights reserved.</p>
        </div>
    </footer>
    
    <!-- Resume Download Modal -->
    <div class="resume-modal" id="resumeModal">
        <div class="modal-content">
            <button class="modal-close" id="modalClose">&times;</button>
            <h3 class="modal-title">Download Resume</h3>
            <p>Please select which version of my resume you'd like to download:</p>
            
            <div class="resume-options">
                <div class="resume-option" data-type="data">
                    <i class="fas fa-database"></i>
                    <h4>Data Science / ML Engineer</h4>
                    <p>Data scientist specializing in machine learning, and AI-driven solutions</p>
                </div>
                <!-- <div class="resume-option" data-type="ai">
                    <i class="fas fa-brain"></i>
                    <h4>AI Engineer</h4>
                    <p>Specialized in machine learning, deep learning, and AI solutions.</p>
                </div> -->
            </div>
            
            <button class="download-btn" id="finalDownloadBtn" disabled>Download Selected Resume</button>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" integrity="sha512-axJX7DJduStuBB8ePC8ryGzacZPr3rdLaIDZitiEgWWk2gsXxEFlm4UW0iNzj2h3wp5mOylgHAzBzM4nRSvTZA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js" integrity="sha512-lPbwGiPWBLOs6Vq0Kkm4T/oYPQwXWqm8KkZTXvxGZqg4TjGZVUVJV2a6Z1rI04yBXTKJ4HhU/xEzoyHvTWFLg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // Initialize mobile menu functionality
        document.addEventListener('DOMContentLoaded', () => {
            const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
            const navLinks = document.querySelector('.nav-links');
            const body = document.body;

            if (mobileMenuToggle && navLinks) {
                mobileMenuToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    mobileMenuToggle.classList.toggle('active');
                    navLinks.classList.toggle('active');
                    body.style.overflow = navLinks.classList.contains('active') ? 'hidden' : '';
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!navLinks.contains(e.target) && !mobileMenuToggle.contains(e.target) && navLinks.classList.contains('active')) {
                        mobileMenuToggle.classList.remove('active');
                        navLinks.classList.remove('active');
                        body.style.overflow = '';
                    }
                });

                // Close menu when clicking a link
                navLinks.querySelectorAll('a').forEach(link => {
                    link.addEventListener('click', () => {
                        mobileMenuToggle.classList.remove('active');
                        navLinks.classList.remove('active');
                        body.style.overflow = '';
                    });
                });
            }
        });

        // Resume download modal functionality - Standalone implementation
        document.addEventListener('DOMContentLoaded', () => {
            const downloadResumeBtn = document.getElementById('downloadResumeBtn');
            const resumeModal = document.getElementById('resumeModal');
            const modalClose = document.getElementById('modalClose');
            const resumeOptions = document.querySelectorAll('.resume-option');
            const finalDownloadBtn = document.getElementById('finalDownloadBtn');
            
            let selectedResumeType = null;
            
            if (downloadResumeBtn && resumeModal) {
                // Add both click and touchend events for better mobile support
                ['click', 'touchend'].forEach(eventType => {
                    downloadResumeBtn.addEventListener(eventType, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        resumeModal.classList.add('active');
                        document.body.style.overflow = 'hidden';
                        
                        // Add animation for modal elements
                        setTimeout(() => {
                            const modalContent = resumeModal.querySelector('.modal-content');
                            if (modalContent) {
                                modalContent.style.transform = 'scale(1)';
                                modalContent.style.opacity = '1';
                            }
                        }, 10);
                    });
                });

                // Prevent default touchstart behavior
                downloadResumeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                });

                // Add reflective effect to modal content
                const modalContent = resumeModal.querySelector('.modal-content');
                if (modalContent) {
                    document.addEventListener('mousemove', (e) => {
                        if (resumeModal.classList.contains('active')) {
                            const rect = modalContent.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const centerX = rect.width / 2;
                            const centerY = rect.height / 2;
                            
                            const rotateX = (y - centerY) / 20;
                            const rotateY = (centerX - x) / 20;
                            
                            modalContent.style.transform = `scale(1) perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                        }
                    });
                }

                if (modalClose) {
                    modalClose.addEventListener('click', () => {
                        closeModal();
                    });
                }

                // Close modal if clicked/touched outside
                ['click', 'touchend'].forEach(eventType => {
                    resumeModal.addEventListener(eventType, (e) => {
                        if (e.target === resumeModal) {
                            closeModal();
                        }
                    });
                });

                function closeModal() {
                    const modalContent = resumeModal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.transform = 'scale(0.8)';
                        modalContent.style.opacity = '0';
                    }
                    
                    setTimeout(() => {
                        resumeModal.classList.remove('active');
                        document.body.style.overflow = 'auto';
                        // Reset transform when modal closes
                        if (modalContent) {
                            modalContent.style.transform = 'scale(0.8)';
                        }
                    }, 300);
                }

                // Handle resume option selection with touch support
                resumeOptions.forEach(option => {
                    ['click', 'touchend'].forEach(eventType => {
                        option.addEventListener(eventType, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Remove active class from all options
                            resumeOptions.forEach(opt => opt.classList.remove('active'));
                            
                            // Add active class to clicked/touched option
                            option.classList.add('active');
                            
                            // Enable download button
                            if (finalDownloadBtn) {
                                finalDownloadBtn.removeAttribute('disabled');
                            }
                            
                            // Set selected resume type
                            selectedResumeType = option.getAttribute('data-type');
                        });
                    });
                    
                    // Prevent default touchstart behavior
                    option.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                    });
                });

                // Handle final download button click with touch support
                if (finalDownloadBtn) {
                    ['click', 'touchend'].forEach(eventType => {
                        finalDownloadBtn.addEventListener(eventType, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            if (selectedResumeType === 'data') {
                                window.location.href = 'https://drive.google.com/uc?export=download&id=1N1kI9pM7fsjf1KIhRDbKqzq_d831PG7J';
                            } else if (selectedResumeType === 'ai') {
                                window.location.href = 'https://drive.google.com/uc?export=download&id=1N1kI9pM7fsjf1KIhRDbKqzq_d831PG7J';
                            }
                            
                            // Close modal after download starts
                            setTimeout(closeModal, 500);
                        });
                    });

                    // Prevent default touchstart behavior
                    finalDownloadBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                    });
                }
            }
        });

        // Header scroll effect
        window.addEventListener('scroll', () => {
            const header = document.getElementById('header');
            if (window.scrollY > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // Timeline animation with staggered reveal
        const timelineItems = document.querySelectorAll('.vertical-timeline .timeline-item');
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry, index) => {
                if (entry.isIntersecting) {
                    // Add staggered delay based on index
                    setTimeout(() => {
                        entry.target.classList.add('visible');
                    }, 300 * index); // 300ms delay between each item
                }
            });
        }, { threshold: 0.2 });
        
        timelineItems.forEach(item => {
            observer.observe(item);
        });

        // Create and add the progress circle
        const progressCircle = document.createElement('div');
        progressCircle.className = 'timeline-progress';
        document.body.appendChild(progressCircle);

        // Timeline progress tracking
        const timeline = document.querySelector('.vertical-timeline');
        const timelineRect = timeline.getBoundingClientRect();
        
        function updateTimelineProgress() {
            const scrollPosition = window.scrollY + window.innerHeight / 2;
            const timelineStart = timelineRect.top + window.scrollY;
            const timelineEnd = timelineRect.bottom + window.scrollY;
            
            // Calculate progress percentage
            let progress = (scrollPosition - timelineStart) / (timelineEnd - timelineStart);
            progress = Math.max(0, Math.min(1, progress));
            
            // Update circle position
            const circleX = timelineRect.left + (timelineRect.width * progress);
            const circleY = scrollPosition;
            progressCircle.style.left = `${circleX}px`;
            progressCircle.style.top = `${circleY}px`;
            
            // Show/hide circle based on timeline visibility
            if (scrollPosition >= timelineStart && scrollPosition <= timelineEnd) {
                progressCircle.classList.add('visible');
            } else {
                progressCircle.classList.remove('visible');
            }
            
            // Highlight cards based on proximity to circle
            timelineItems.forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const itemCenter = itemRect.top + itemRect.height / 2;
                const distance = Math.abs(circleY - itemCenter);
                
                if (distance < 100) { // Adjust this value to change the highlight range
                    item.querySelector('.timeline-content').classList.add('highlighted');
                } else {
                    item.querySelector('.timeline-content').classList.remove('highlighted');
                }
            });
        }
        
        // Update on scroll and resize
        window.addEventListener('scroll', updateTimelineProgress);
        window.addEventListener('resize', () => {
            const newTimelineRect = timeline.getBoundingClientRect();
            timelineRect = newTimelineRect;
            updateTimelineProgress();
        });
        
        // Initial update
        updateTimelineProgress();

        // Hero canvas - Particle system
        const heroCanvas = document.getElementById('hero-canvas');
        const heroScene = new THREE.Scene();
        const heroCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const heroRenderer = new THREE.WebGLRenderer({
            canvas: heroCanvas,
            alpha: true
        });
        heroRenderer.setSize(window.innerWidth, window.innerHeight);
        heroRenderer.setClearColor(0x000000, 0);
        
        heroCamera.position.z = 30;
        
        // Create particles
        const particles = new THREE.Group();
        heroScene.add(particles);
        
        const particleCount = 200;
        const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({
            color: 0x61dafb,
            transparent: true,
            opacity: 0.7
        });
        
        // Create particle system
        for (let i = 0; i < particleCount; i++) {
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Random position
            particle.position.x = Math.random() * 60 - 30;
            particle.position.y = Math.random() * 40 - 20;
            particle.position.z = Math.random() * 40 - 20;
            
            // Give each particle properties
            particle.userData = {
                velocity: new THREE.Vector3(
                    Math.random() * 0.02 - 0.01,
                    Math.random() * 0.02 - 0.01,
                    Math.random() * 0.02 - 0.01
                ),
                originalPosition: new THREE.Vector3(
                    particle.position.x,
                    particle.position.y,
                    particle.position.z
                )
            };
            
            particles.add(particle);
        }
        
        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        
        // Animation
        function animateHero() {
            requestAnimationFrame(animateHero);
            
            particles.children.forEach(particle => {
                // Update position based on velocity
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;
                
                // Mouse influence (increased strength)
                particle.position.x += mouseX * 0.05;
                particle.position.y += mouseY * 0.05;
                
                // Return to original position gradually (reduced strength)
                particle.position.x += (particle.userData.originalPosition.x - particle.position.x) * 0.005;
                particle.position.y += (particle.userData.originalPosition.y - particle.position.y) * 0.005;
                particle.position.z += (particle.userData.originalPosition.z - particle.position.z) * 0.005;
                
                // Soft pulsing
                particle.scale.x = particle.scale.y = particle.scale.z = 0.8 + Math.sin(Date.now() * 0.001 + particle.position.x) * 0.2;
            });
            
            heroRenderer.render(heroScene, heroCamera);
        }
        
        animateHero();
        
        // Skills visualization - improved and interactive
        const skillsCanvas = document.getElementById('skills-canvas');
        const skillsScene = new THREE.Scene();
        const skillsCamera = new THREE.PerspectiveCamera(75, skillsCanvas.clientWidth / skillsCanvas.clientHeight, 0.1, 1000);
        
        const skillsRenderer = new THREE.WebGLRenderer({
            canvas: skillsCanvas,
            alpha: true,
            antialias: true
        });
        skillsRenderer.setSize(skillsCanvas.clientWidth, skillsCanvas.clientHeight);
        skillsRenderer.setClearColor(0x000000, 0);
        
        skillsCamera.position.z = 40;
        
        // Skills data with more detailed information
        const skillsData = [
            // Languages
            { name: "Python", category: "Languages", size: 1.8, level: 95, description: "Expert level, daily use for ML pipelines and data analysis" },
            { name: "R", category: "Languages", size: 1.2, level: 85, description: "Statistical analysis and data visualization" },
            { name: "SQL", category: "Languages", size: 1.4, level: 90, description: "Complex queries, database optimization, ETL processes" },
            
            // Machine Learning
            { name: "PyTorch", category: "Machine Learning", size: 1.6, level: 90, description: "Deep learning models for NLP and time series analysis" },
            { name: "TensorFlow", category: "Machine Learning", size: 1.5, level: 85, description: "Production ML systems and model deployment" },
            { name: "scikit-learn", category: "Machine Learning", size: 1.4, level: 95, description: "Traditional ML algorithms and preprocessing pipelines" },
            { name: "Keras", category: "Machine Learning", size: 1.3, level: 85, description: "High-level neural network APIs" },
            
            // Platforms
            { name: "Databricks", category: "Platforms", size: 1.6, level: 90, description: "Data processing at scale, ML workflow automation" },
            { name: "Azure", category: "Platforms", size: 1.4, level: 85, description: "End-to-end cloud solutions from ML model deployment and CI/CD pipelines to containerized applications, virtual infrastructure, and enterprise data storage." },
            
            // DevOps
            { name: "Docker", category: "DevOps", size: 1.3, level: 85, description: "Containerization for reproducible environments" },
            { name: "Kubernetes", category: "DevOps", size: 1.3, level: 80, description: "Orchestration for scalable ML systems" },
            { name: "Git", category: "DevOps", size: 1.2, level: 90, description: "Version control and collaboration" },
            { name: "CI/CD", category: "DevOps", size: 1.2, level: 85, description: "Automated testing and deployment pipelines" },
            
            // GenAI
            { name: "LangChain", category: "GenAI", size: 1.7, level: 90, description: "Framework for LLM application development" },
            { name: "LLM API Orchestration", category: "GenAI", size: 1.7, level: 90, description: "Building multi-provider (OpenAI, Anthropic, Groq, etc.) model wrappers and API interfaces for production applications" },
            { name: "Hugging Face", category: "GenAI", size: 1.7, level: 90, description: "Open-source ecosystem for accessing, fine-tuning, and deploying transformer-based models and datasets" },
            
            // NLP
            { name: "Transformer Models", category: "NLP", size: 1.4, level: 85, description: "State-of-the-art architectures (BERT, RoBERTa, etc.) for contextual text understanding, classification, and embeddings" },
            { name: "FAISS & Pinecone", category: "NLP", size: 1.4, level: 85, description: "Libraries for building fast and scalable vector search systems with dense embeddings" },
            { name: "NLTK & spaCy", category: "NLP", size: 1.4, level: 85, description: "Toolkits for text processing (tokenization, lemmatization, entity recognition, encoding), linguistic analysis, and traditional NLP pipelines" },
            
            // Tools
            { name: "Linux", category: "Tools", size: 1.2, level: 85, description: "Server administration and automation" },
            { name: "Ubuntu", category: "Tools", size: 1.2, level: 85, description: "High-performance Linux distribution for distributed computing systems and parallel processing environments" },
            { name: "RHEL", category: "Tools", size: 1.2, level: 85, description: "Enterprise Linux platform for mission-critical workloads, with advanced security and containerization capabilities" },
            { name: "WSL", category: "Tools", size: 1.2, level: 85, description: "Windows Subsystem for Linux enabling seamless cross-platform development and testing of Linux-based applications" }
        ];
        
        // Colors by category with improved palette
        const categoryColors = {
            "Languages": 0xfdaceb,  // Pink
            "Machine Learning": 0xff6b6b,  // Red
            "Platforms": 0xebfdac,  // Light green
            "DevOps": 0xacfdbe,     // Mint
            "GenAI": 0xacebfd,      // Light blue
            "NLP": 0xbeacfd,        // Lavender
            "Tools": 0xfde7ac       // Light yellow
        };
        
        // Create nodes for skills
        const skillNodes = new THREE.Group();
        skillsScene.add(skillNodes);
        
        // Store references for interactivity
        const nodeReferences = {};
        
        // Create skill info panel in HTML
        const skillsContainer = document.querySelector('.skills-container');
        const skillInfoPanel = document.createElement('div');
        skillInfoPanel.className = 'skill-info-panel';
        skillInfoPanel.innerHTML = `
            <div class="skill-info-content">
                <h3>${window.innerWidth <= 768 ? 'Click a skill to see details' : 'Hover over a skill to see details'}</h3>
                <p class="skill-description"></p>
            </div>
        `;
        skillsContainer.appendChild(skillInfoPanel);
        
        // Create HTML labels for each node
        const skillLabels = {};
        
        // Define boundaries for node movement
        const BOUNDARY_X = 35;
        const BOUNDARY_Y = 35;
        const BOUNDARY_Z = 35;
        
        // Calculate category centers
        const categoryCenters = {};
        Object.keys(categoryColors).forEach(category => {
            categoryCenters[category] = new THREE.Vector3();
        });
        
        // Create nodes and calculate initial positions
        skillsData.forEach(skill => {
            // Create the HTML label
            const label = document.createElement('div');
            label.className = 'skill-node-label';
            label.textContent = skill.name;
            skillsContainer.appendChild(label); // Changed from document.body to skillsContainer
            skillLabels[skill.name] = label;
            
            // Create the 3D node
            const geometry = new THREE.SphereGeometry(skill.size, 32, 32);
            const material = new THREE.MeshBasicMaterial({
                color: categoryColors[skill.category],
                transparent: true,
                opacity: 0.8
            });
            
            const node = new THREE.Mesh(geometry, material);
            
            // Position relative to category center
            const categoryCenter = categoryCenters[skill.category];
            const radius = 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            node.position.x = categoryCenter.x + radius * Math.sin(phi) * Math.cos(theta);
            node.position.y = categoryCenter.y + radius * Math.sin(phi) * Math.sin(theta);
            node.position.z = categoryCenter.z + radius * Math.cos(phi);
            
            // Add skill data to node
            node.userData = {
                name: skill.name,
                category: skill.category,
                level: skill.level,
                description: skill.description,
                velocity: new THREE.Vector3(0, 0, 0),
                highlighted: false,
                originalScale: new THREE.Vector3(1, 1, 1),
                originalOpacity: 0.8,
                categoryCenter: categoryCenter
            };
            
            nodeReferences[skill.name] = node;
            skillNodes.add(node);
        });
        
        // Position category centers in a circle
        const categoryCount = Object.keys(categoryColors).length;
        const categoryRadius = 20;
        Object.keys(categoryColors).forEach((category, index) => {
            const angle = (index / categoryCount) * Math.PI * 2;
            categoryCenters[category].x = categoryRadius * Math.cos(angle);
            categoryCenters[category].y = categoryRadius * Math.sin(angle);
            categoryCenters[category].z = 0;
        });
        
        // Make legend interactive
        const legendItems = document.querySelectorAll('.legend-item');
        let selectedCategory = null;
        let targetCameraZ = 40;
        let targetCameraPosition = new THREE.Vector3(0, 0, 40);
        let isZoomed = false;
        let zoomStartTime = 0;
        const ZOOM_DURATION = 1000; // Duration in milliseconds
        
        legendItems.forEach(item => {
            item.style.cursor = 'pointer';
            item.addEventListener('click', () => {
                const category = item.querySelector('span').textContent;
                selectedCategory = selectedCategory === category ? null : category;
                isZoomed = selectedCategory !== null;
                zoomStartTime = Date.now();
                
                // Reset all nodes to their original properties first
                skillNodes.children.forEach(node => {
                    node.scale.copy(node.userData.originalScale);
                    node.material.opacity = node.userData.originalOpacity;
                    node.userData.highlighted = false;
                });
                
                // Update legend items
                legendItems.forEach(legendItem => {
                    if (legendItem.querySelector('span').textContent === category) {
                        legendItem.style.opacity = selectedCategory ? '1' : '0.8';
                        legendItem.style.transform = selectedCategory ? 'scale(1.1)' : 'scale(1)';
                    } else {
                        legendItem.style.opacity = selectedCategory ? '0.4' : '0.8';
                        legendItem.style.transform = 'scale(1)';
                    }
                });
                
                // Set target camera position with improved centering
                if (selectedCategory) {
                    const center = categoryCenters[selectedCategory];
                    // Adjust camera position to better center the selected category
                    targetCameraPosition.set(center.x, center.y, center.z + 12);
                    targetCameraZ = 12;
                    
                    // Update node visibility and highlighting for selected category
                    skillNodes.children.forEach(node => {
                        if (node.userData.category === selectedCategory) {
                            node.material.opacity = 1;
                            node.userData.highlighted = true;
                            // Ensure nodes are properly positioned around the center
                            const radius = 2;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            node.position.x = center.x + radius * Math.sin(phi) * Math.cos(theta);
                            node.position.y = center.y + radius * Math.sin(phi) * Math.sin(theta);
                            node.position.z = center.z + radius * Math.cos(phi);
                        } else {
                            node.material.opacity = 0.3;
                            node.userData.highlighted = false;
                        }
                    });
                } else {
                    targetCameraPosition.set(0, 0, 40);
                    targetCameraZ = 40;
                }
            });
        });
        
        // Raycaster for mouse interactions
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;
        
        // Update mouse position on move
        skillsCanvas.addEventListener('mousemove', (event) => {
            const rect = skillsCanvas.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        });

        // Add touch position update
        skillsCanvas.addEventListener('touchmove', (event) => {
            const rect = skillsCanvas.getBoundingClientRect();
            const touch = event.touches[0];
            
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        });
        
        // Helper function to update skill info panel
        function updateSkillInfoPanel(skill) {
            const panel = document.querySelector('.skill-info-panel');
            const title = panel.querySelector('h3');
            const description = panel.querySelector('.skill-description');
            
            title.textContent = skill.name;
            description.textContent = skill.description;
            
            // Add active class for mobile slide-up animation
            panel.classList.add('active');
            
            // Highlight this node and its category
            skillNodes.children.forEach(node => {
                if (node.userData.name === skill.name) {
                    node.material.opacity = 1;
                    node.scale.set(1.3, 1.3, 1.3);
                    node.userData.highlighted = true;
                } else if (node.userData.category === skill.category) {
                    node.material.opacity = 0.9;
                    node.userData.highlighted = false;
                } else {
                    node.material.opacity = 0.3;
                    node.userData.highlighted = false;
                    node.scale.copy(node.userData.originalScale);
                }
            });
        }
        
        function resetNodes() {
            skillNodes.children.forEach(node => {
                node.material.opacity = node.userData.originalOpacity;
                node.scale.copy(node.userData.originalScale);
                node.userData.highlighted = false;
            });
            
            const panel = document.querySelector('.skill-info-panel');
            panel.classList.remove('active');
            
            // Reset panel content after animation
            setTimeout(() => {
                const title = panel.querySelector('h3');
                const description = panel.querySelector('.skill-description');
                if (!panel.classList.contains('active')) {
                    title.textContent = window.innerWidth <= 768 ? 'Click a skill to see details' : 'Hover over a skill to see details';
                    description.textContent = '';
                }
            }, 300);
        }
        
        // Animation function for skills graph
        function animateSkills() {
            requestAnimationFrame(animateSkills);
            
            // Calculate zoom progress
            const zoomProgress = Math.min(1, (Date.now() - zoomStartTime) / ZOOM_DURATION);
            
            // Smooth camera movement with easing
            if (isZoomed) {
                const easeOutExpo = 1 - Math.pow(2, -10 * zoomProgress);
                skillsCamera.position.lerp(targetCameraPosition, 0.05 * easeOutExpo);
            } else {
                skillsCamera.position.lerp(targetCameraPosition, 0.05);
            }
            
            // Update all node labels
                    skillNodes.children.forEach(node => {
                            const label = skillLabels[node.userData.name];
                            const vector = new THREE.Vector3();
                            vector.copy(node.position);
                            
                            // Project the 3D position to 2D screen position
                            vector.project(skillsCamera);
                            
                            const x = (vector.x * 0.5 + 0.5) * skillsCanvas.clientWidth;
                            const y = (vector.y * -0.5 + 0.5) * skillsCanvas.clientHeight;
                            
                // Position relative to the skills container
                const containerRect = skillsContainer.getBoundingClientRect();
                label.style.position = 'absolute';
                            label.style.left = `${x}px`;
                            label.style.top = `${y}px`;
                            
                // Show labels for all nodes
                                label.style.opacity = '0.8';
                                label.style.fontWeight = 'normal';
                                label.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                                label.style.zIndex = '10';
            });
            
            // Check for intersections
            raycaster.setFromCamera(mouse, skillsCamera);
            const intersects = raycaster.intersectObjects(skillNodes.children);
            
            if (intersects.length === 0) {
                if (intersectedObject) {
                    resetNodes();
                    intersectedObject = null;
                    skillsCanvas.style.cursor = 'default';
                }
            } else {
                const intersectedNode = intersects[0].object;
                skillsCanvas.style.cursor = 'pointer';
                
                if (intersectedObject !== intersectedNode) {
                    intersectedObject = intersectedNode;
                    const skill = intersectedObject.userData;
                    updateSkillInfoPanel(skill);
                    
                    // Highlight hovered node's label
                    const hoveredLabel = skillLabels[skill.name];
                    hoveredLabel.style.opacity = '1';
                    hoveredLabel.style.fontWeight = 'bold';
                    hoveredLabel.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
                    hoveredLabel.style.zIndex = '100';
                }
            }
            
            // Only apply force-directed layout when not zoomed
            if (!isZoomed) {
            skillNodes.children.forEach(node1 => {
                if (node1.userData.highlighted) {
                    // Don't apply forces to highlighted node
                    return;
                }
                
                    // Attraction to category center (reduced strength)
                    const categoryCenter = node1.userData.categoryCenter;
                    const dx = categoryCenter.x - node1.position.x;
                    const dy = categoryCenter.y - node1.position.y;
                    const dz = categoryCenter.z - node1.position.z;
                    
                    // Very weak attraction to category center
                    node1.userData.velocity.x += dx * 0.0005;
                    node1.userData.velocity.y += dy * 0.0005;
                    node1.userData.velocity.z += dz * 0.0005;
                    
                    // Repulsion between nodes in same category (increased strength)
                skillNodes.children.forEach(node2 => {
                        if (node1 !== node2 && node1.userData.category === node2.userData.category) {
                        const dx = node1.position.x - node2.position.x;
                        const dy = node1.position.y - node2.position.y;
                        const dz = node1.position.z - node2.position.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                            // Increased minimum distance between nodes
                            if (distance < 8) {
                                const repulsionForce = 0.002 / (distance * distance);
                            node1.userData.velocity.x += dx * repulsionForce;
                            node1.userData.velocity.y += dy * repulsionForce;
                            node1.userData.velocity.z += dz * repulsionForce;
                        }
                    }
                });
                
                    // Stronger damping for slower movement
                    node1.userData.velocity.x *= 0.98;
                    node1.userData.velocity.y *= 0.98;
                    node1.userData.velocity.z *= 0.98;
                    
                    // Update position with boundary constraints
                node1.position.x += node1.userData.velocity.x;
                node1.position.y += node1.userData.velocity.y;
                node1.position.z += node1.userData.velocity.z;
                
                    // Enforce boundaries (reduced to keep nodes closer to center)
                    node1.position.x = Math.max(-BOUNDARY_X * 0.8, Math.min(BOUNDARY_X * 0.8, node1.position.x));
                    node1.position.y = Math.max(-BOUNDARY_Y * 0.8, Math.min(BOUNDARY_Y * 0.8, node1.position.y));
                    node1.position.z = Math.max(-BOUNDARY_Z * 0.8, Math.min(BOUNDARY_Z * 0.8, node1.position.z));
                });
            }
            
            skillsRenderer.render(skillsScene, skillsCamera);
        }
        
        // Start animation when skills section becomes visible
        const skillsSection = document.getElementById('skills');
        const skillsObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                animateSkills();
                skillsObserver.disconnect();
            }
        }, { threshold: 0.1 });
        
        skillsObserver.observe(skillsSection);
        
        // Resize event handlers
        window.addEventListener('resize', () => {
            // Update hero canvas
            heroCamera.aspect = window.innerWidth / window.innerHeight;
            heroCamera.updateProjectionMatrix();
            heroRenderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update skills canvas
            skillsCamera.aspect = skillsCanvas.clientWidth / skillsCanvas.clientHeight;
            skillsCamera.updateProjectionMatrix();
            skillsRenderer.setSize(skillsCanvas.clientWidth, skillsCanvas.clientHeight);
            
            // Update mobile-specific settings
            updateCameraForMobile();
            
            // Force a re-render
            skillsRenderer.render(skillsScene, skillsCamera);
        });
        
        // Initial mobile setup
        updateCameraForMobile();

        // Mobile-specific camera adjustments
        function updateCameraForMobile() {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                // Adjust camera position for mobile - bring it closer but maintain visibility
                skillsCamera.position.z = 35;
                targetCameraZ = 35;
                targetCameraPosition.z = 35;
                
                // Adjust category radius for mobile - keep it larger for better visibility
                const categoryRadius = 15;
                Object.keys(categoryColors).forEach((category, index) => {
                    const angle = (index / categoryCount) * Math.PI * 2;
                    categoryCenters[category].x = categoryRadius * Math.cos(angle);
                    categoryCenters[category].y = categoryRadius * Math.sin(angle);
                    categoryCenters[category].z = 0;
                });
                
                // Adjust node sizes for mobile
                skillNodes.children.forEach(node => {
                    node.scale.set(1.2, 1.2, 1.2);
                    node.userData.originalScale.set(1.2, 1.2, 1.2);
                });
                
                // Adjust boundaries to keep nodes more visible
                BOUNDARY_X = 20;
                BOUNDARY_Y = 20;
                BOUNDARY_Z = 20;
                
                // Reset node positions with larger radius
                skillNodes.children.forEach(node => {
                    const categoryCenter = node.userData.categoryCenter;
                    const radius = 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    node.position.x = categoryCenter.x + radius * Math.sin(phi) * Math.cos(theta);
                    node.position.y = categoryCenter.y + radius * Math.sin(phi) * Math.sin(theta);
                    node.position.z = categoryCenter.z + radius * Math.cos(phi);
                });
            }
        }
        
        // Enhanced touch event handlers for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouching = false;
        let lastTouchTime = 0;
        let touchCount = 0;
        let selectedNode = null;
        let touchStartTime = 0;

        skillsCanvas.addEventListener('touchstart', (event) => {
            isTouching = true;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            touchStartTime = Date.now();
            const currentTime = Date.now();
            
            // Check for node selection
            raycaster.setFromCamera(mouse, skillsCamera);
            const intersects = raycaster.intersectObjects(skillNodes.children);
            
            if (intersects.length > 0) {
                const intersectedNode = intersects[0].object;
                selectedNode = intersectedNode;
                const skill = intersectedNode.userData;
                updateSkillInfoPanel(skill);
                skillsCanvas.style.cursor = 'pointer';
                event.preventDefault();
                return;
            }
            
            // Handle double tap for zoom
            if (currentTime - lastTouchTime < 300) {
                touchCount++;
                if (touchCount === 2) {
                    // Double tap detected - toggle zoom
                    const category = selectedCategory || Object.keys(categoryColors)[0];
                    const legendItem = Array.from(legendItems).find(item => 
                        item.querySelector('span').textContent === category
                    );
                    if (legendItem) {
                        legendItem.click();
                    }
                    touchCount = 0;
                }
            } else {
                touchCount = 1;
            }
            lastTouchTime = currentTime;
            
            event.preventDefault();
        });
        
        skillsCanvas.addEventListener('touchmove', (event) => {
            if (!isTouching) return;
            
            // If we have a selected node, don't rotate
            if (selectedNode) {
                event.preventDefault();
                return;
            }
            
            if (isZoomed) return;
            
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            
            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;
            
            // Smoother rotation with reduced sensitivity
            skillNodes.rotation.y += deltaX * 0.002;
            skillNodes.rotation.x += deltaY * 0.002;
            
            touchStartX = touchX;
            touchStartY = touchY;
            
            event.preventDefault();
        });
        
        skillsCanvas.addEventListener('touchend', (event) => {
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - touchStartTime;
            
            isTouching = false;
            
            // If it was a short tap and we have a selected node, keep it selected
            if (touchDuration < 300 && selectedNode) {
                return;
            }
            
            selectedNode = null;
            skillsCanvas.style.cursor = 'default';
            
            // Reset nodes after a short delay
            setTimeout(() => {
                if (!selectedNode) {
                    resetNodes();
                }
            }, 2000);
            
            event.preventDefault();
        });

        // Update mobile settings on orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(updateCameraForMobile, 100);
        });

        // Add this after the existing Three.js code
        
        // About section avatar animation
        const aboutCanvas = document.getElementById('about-canvas');
        const aboutScene = new THREE.Scene();
        const aboutCamera = new THREE.PerspectiveCamera(50, aboutCanvas.clientWidth / aboutCanvas.clientHeight, 0.1, 1000);
        
        const aboutRenderer = new THREE.WebGLRenderer({
            canvas: aboutCanvas,
            alpha: true,
            antialias: true
        });
        aboutRenderer.setSize(aboutCanvas.clientWidth, aboutCanvas.clientHeight);
        aboutRenderer.setClearColor(0xf8e6d8, 1); // Match the background color
        
        // Create a texture loader with error handling
        const textureLoader = new THREE.TextureLoader();
        
        // Load the avatar texture with error handling
        const avatarTexture = textureLoader.load(
            'logos/your-avatar.png', // Update the path to your image
            function(texture) {
                console.log('Avatar texture loaded successfully');
                // Adjust UV coordinates if needed
                texture.flipY = false; // Try this if the image appears upside down
            },
            undefined,
            function(err) {
                console.error('Error loading avatar texture:', err);
            }
        );
        
        // Create a larger plane geometry to make the avatar more visible
        const avatarGeometry = new THREE.PlaneGeometry(3.5, 3.5);
        const avatarMaterial = new THREE.MeshBasicMaterial({
            map: avatarTexture,
            transparent: true,
            opacity: 1
        });
        
        const avatar = new THREE.Mesh(avatarGeometry, avatarMaterial);
        aboutScene.add(avatar);
        
        // Position camera closer to see the avatar better
        aboutCamera.position.z = 3;
        
        // Animation variables
        let blinkTimeout;
        const eyeClosedTexture = textureLoader.load(
            'your-avatar-blink.png', // Update the path to your blinking image
            function(texture) {
                console.log('Blink texture loaded successfully');
                texture.flipY = false;
            },
            undefined,
            function(err) {
                console.error('Error loading blink texture:', err);
            }
        );
        const normalTexture = avatarTexture;
        
        function blink() {
            // Change to closed eyes texture
            avatarMaterial.map = eyeClosedTexture;
            avatarMaterial.needsUpdate = true;
            
            // Open eyes after 150ms
            setTimeout(() => {
                avatarMaterial.map = normalTexture;
                avatarMaterial.needsUpdate = true;
                
                // Schedule next blink
                blinkTimeout = setTimeout(blink, Math.random() * 4000 + 2000);
            }, 150);
        }
        
        // Start blinking
        setTimeout(blink, Math.random() * 2000 + 1000);
        
        // Subtle movement animation
        function animateAvatar() {
            requestAnimationFrame(animateAvatar);
            
            // Add subtle floating movement
            avatar.position.y = Math.sin(Date.now() * 0.001) * 0.1;
            avatar.rotation.z = Math.sin(Date.now() * 0.0005) * 0.02;
            
            aboutRenderer.render(aboutScene, aboutCamera);
        }
        
        // Start animation
        animateAvatar();
        
        // Handle resize
        window.addEventListener('resize', () => {
            const width = aboutCanvas.clientWidth;
            const height = aboutCanvas.clientHeight;
            
            aboutCamera.aspect = width / height;
            aboutCamera.updateProjectionMatrix();
            
            aboutRenderer.setSize(width, height);
        });
        
        // Initial resize call
        const initialResize = () => {
            const width = aboutCanvas.clientWidth;
            const height = aboutCanvas.clientHeight;
            aboutCamera.aspect = width / height;
            aboutCamera.updateProjectionMatrix();
            aboutRenderer.setSize(width, height, false);
        };
        initialResize();

        // Mobile menu functionality
        const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
        const navLinks = document.querySelector('.nav-links');
        const body = document.body;

        mobileMenuToggle.addEventListener('click', () => {
            mobileMenuToggle.classList.toggle('active');
            navLinks.classList.toggle('active');
            body.style.overflow = navLinks.classList.contains('active') ? 'hidden' : '';
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!navLinks.contains(e.target) && !mobileMenuToggle.contains(e.target) && navLinks.classList.contains('active')) {
                mobileMenuToggle.classList.remove('active');
                navLinks.classList.remove('active');
                body.style.overflow = '';
            }
        });

        // Close menu when clicking a link
        navLinks.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                mobileMenuToggle.classList.remove('active');
                navLinks.classList.remove('active');
                body.style.overflow = '';
            });
        });

        // Add touch event handler for closing the panel when tapping outside
        document.addEventListener('touchstart', (event) => {
            const panel = document.querySelector('.skill-info-panel');
            const skillsContainer = document.querySelector('.skills-container');
            
            if (panel.classList.contains('active') && 
                !panel.contains(event.target) && 
                !skillsContainer.contains(event.target)) {
                resetNodes();
            }
        });
    </script>
    <button id="goUpBtn" class="go-up-btn" aria-label="Go to top">
        <i class="fas fa-arrow-up"></i>
    </button>
    <script>
        // Go Up Button functionality
        const goUpBtn = document.getElementById('goUpBtn');

        // Show/hide button based on scroll position
        window.addEventListener('scroll', () => {
            if (window.scrollY > 500) {
                goUpBtn.classList.add('visible');
            } else {
                goUpBtn.classList.remove('visible');
            }
        });

        // Scroll to top when button is clicked
        goUpBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Add touch support for mobile
        goUpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior
        });

        goUpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>